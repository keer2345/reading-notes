# [Do Things: A Clojure Crash Course](https://www.braveclojure.com/do-things/)
## Syntax
### Forms
```clj
1
"a string"
["a" "vector" "of" "strings"]
```
```clj
(operator operand1 operand2 ... operandn)
```
```clj
(+ 1 2 3)
; => 6

(str "It was the panda " "in the library " "with a dust buster")
; => "It was the panda in the library with a dust buster"
```
### Control Flow
#### if
```clj
(if boolean-form
  then-form
  optional-else-form)
```

```clj
(if true
  "By Zeus's hammer!"
  "By Aquaman's trident!")
; => "By Zeus's hammer!"

(if false
  "By Zeus's hammer!"
  "By Aquaman's trident!")
; => "By Aquaman's trident!"

(if false
  "By Odin's Elbow!")
; => nil
```
#### do
```clj
(if true
  (do (println "Success!")
      "By Zeus's hammer!")
  (do (println "Failure!")
      "By Aquaman's trident!"))
; => Success!
; => "By Zeus's hammer!"
```

#### when
```clj
(when true
  (println "Success!")
  "abra cadabra")
; => Success!
; => "abra cadabra"
```
#### nil, true, false, Truthiness, Equality, and Boolean Expressions
Clojure has `true` and `false` values. `nil` is used to indicate *no value* in Clojure. You can check if a value is `nil` with the appropriately named `nil?` function:
```clj
(nil? 1)
; => false

(nil? nil)
; => true
```

Both `nil` and `false` are used to represent logical falsiness, whereas all other values are logically truthy. 
```clj
(if "bears eat beets"
  "bears beets Battlestar Galactica")
; => "bears beets Battlestar Galactica"

(if nil
  "This won't be the result because nil is falsey"
  "nil is falsey")
; => "nil is falsey"
```

Clojure’s equality operator is `=`:
```clj
(= 1 1)
; => true

(= nil nil)
; => true

(= 1 2)
; => false
```

Clojure uses the Boolean operators `or` and `and`. `or` returns either the first truthy value or the last value. `and` returns the first falsey value or, if no values are falsey, the last truthy values. 
```clj
(or false nil :large_I_mean_venti :why_cant_I_just_say_large)
; => :large_I_mean_venti

(or (= 0 1) (= "yes" "no"))
; => false

(or nil)
; => nil

(and :free_wifi :hot_coffee)
; => :hot_coffee

(and :feelin_super_cool nil false)
; => nil
```


### def

You use `def` to *bind* a name to a value in Clojure:
```clj
(def failed-protagonist-names
  ["Larry Potter" "Doreen the Explorer" "The Incredible Bulk"])

failed-protagonist-names
; => ["Larry Potter" "Doreen the Explorer" "The Incredible Bulk"]
```

For example, in Ruby:
```ruby
severity = :mild
error_message = "OH GOD! IT'S A DISASTER! WE'RE "
if severity == :mild
  error_message = error_message + "MILDLY INCONVENIENCED!"
else
  error_message = error_message + "DOOOOOOOMED!"
end
```
You might be tempted to do something similar in Clojure:
```clj
(def severity :mild)
(def error-message "OH GOD! IT'S A DISASTER! WE'RE ")
(if (= severity :mild)
  (def error-message (str error-message "MILDLY INCONVENIENCED!"))
  (def error-message (str error-message "DOOOOOOOMED!")))
```
```clj
(defn error-message
  [severity]
  (str "OH GOD! IT'S A DISASTER! WE'RE "
       (if (= severity :mild)
         "MILDLY INCONVENIENCED!"
         "DOOOOOOOMED!")))

(error-message :mild)
; => "OH GOD! IT'S A DISASTER! WE'RE MILDLY INCONVENIENCED!"
```

## Data Structures
All of Clojure’s data structures are immutable, meaning you can’t change them in place. For example, in Ruby you could do the following to reassign the failed protagonist name at index 0:
```ruby
failed_protagonist_names = [
  "Larry Potter",
  "Doreen the Explorer",
  "The Incredible Bulk"
]
failed_protagonist_names[0] = "Gary Potter"

failed_protagonist_names
# => [
#   "Gary Potter",
#   "Doreen the Explorer",
#   "The Incredible Bulk"
# ]
```

### Numbers
Here’s an integer, a float, and a ratio, respectively:
```clj
93
1.2
1/5
```
### Strings
```clj
"Lord Voldemort"
"\"He who must not be named\""
"\"Great cow of Moscow!\" - Hermes Conrad"

(def name "Chewbacca")
(str "\"Uggllglglglglglglglll\" - " name)
; => "Uggllglglglglglglglll" - Chewbacca
```
### Maps
```clj
{}

{:first-name "Charlie"
 :last-name "McFishwich"}

{"string-key" +}

{:name {:first "John" :middle "Jacob" :last "Jingleheimerschmidt"}}
```

> Notice that map values can be of any type—strings, numbers, maps, vectors, even functions. Clojure don’t care!

Besides using map literals, you can use the `hash-map` function to create a map:
```clj
(hash-map :a 1 :b 2)
; => {:a 1 :b 2}
```
You can look up values in maps with the `get` function:
```clj
(get {:a 0 :b 1} :b)
; => 1

(get {:a 0 :b {:c "ho hum"}} :b)
; => {:c "ho hum"}
```

`get` will return `nil` if it doesn’t find your key, or you can give it a default value to return, such as `"unicorns?"`:
```clj
(get {:a 0 :b 1} :c)
; => nil

(get {:a 0 :b 1} :c "unicorns?")
; => "unicorns?"
```

The `get-in` function lets you look up values in nested maps:
```clj
(get-in {:a 0 :b {:c "ho hum"}} [:b :c])
; => "ho hum"
```

Another way to look up a value in a map is to treat the map like a function with the key as its argument:
```clj
({:name "The Human Coffeepot"} :name)
; => "The Human Coffeepot"
```
### Keywords
```clj
:a
:rumplestiltsken
:34
:_?
 

(:a {:a 1 :b 2 :c 3})
; => 1
 

(get {:a 1 :b 2 :c 3} :a)
; => 1
 

(:d {:a 1 :b 2 :c 3} "No gnome knows homes like Noah knows")
; => "No gnome knows homes like Noah knows"
```

### Vectors
```clj
[3 2 1]

(get [3 2 1] 0)
; => 3

(get ["a" {:name "Pugsley Winterbottom"} "c"] 1)
; => {:name "Pugsley Winterbottom"}

(vector "creepy" "full" "moon")
; => ["creepy" "full" "moon"]

 
(conj [1 2 3] 4)
; => [1 2 3 4]
```
### Lists
```clj
'(1 2 3 4)
; => (1 2 3 4)

(nth '(:a :b :c) 0)
; => :a

(nth '(:a :b :c) 2)
; => :c

(list 1 "two" {3 4})
; => (1 "two" {3 4})
(conj '(1 2 3) 4)
; => (4 1 2 3)
```


### Sets
```clj
#{"kurt vonnegut" 20 :icicle}

(hash-set 1 1 2 2)
; => #{1 2}

(conj #{:a :b} :b)
; => #{:a :b}

(set [3 3 3 4 4])
; => #{3 4}
```
```clj
(contains? #{:a :b} :a)
; => true

(contains? #{:a :b} 3)
; => false

(contains? #{nil} nil)
; => true

(:a #{:a :b})
; => :a

(get #{:a :b} :a)
; => :a

(get #{:a nil} nil)
; => nil

(get #{:a :b} "kurt vonnegut")
; => nil
```

## Functions

-    Calling functions
-    How functions differ from macros and special forms
-    Defining functions
-    Anonymous functions
-    Returning functions

###  Calling Functions
```clj
(+ 1 2 3 4)
(* 1 2 3 4)
(first [1 2 3 4])
```
```clj
(or + -)
; => #<core$_PLUS_ clojure.core$_PLUS_@76dace31>

((or + -) 1 2 3)
; => 6

((and (= 1 1) +) 1 2 3)
; => 6

((first [+ 0]) 1 2 3)
; => 6

(inc 1.1)
; => 2.1

(map inc [0 1 2 3])
; => (1 2 3 4)

(+ (inc 199) (/ 100 (- 7 2)))
(+ 200 (/ 100 (- 7 2))) ; evaluated "(inc 199)"
(+ 200 (/ 100 5)) ; evaluated (- 7 2)
(+ 200 20) ; evaluated (/ 100 5)
220 ; final evaluation

```

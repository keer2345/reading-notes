# [LISP Tutorial 1: Basic LISP Programming](https://www2.cs.sfu.ca/CourseCentral/310/pwfong/Lisp/1/tutorial1.html)

## LISP Expressions

LISP Enviroment like the following:

```lisp
USER(1):
```

Or:

```lisp
CL-USER>
```

The Common LISP environment follows the algorithm below when interacting with users:

```
loop
  read in an expression from the console;
  evaluate the expression;
  print the result of evaluation to the console;
end loop.
```

For example, if you want to comput the value of `(2 * cos(0) * (4 + 6)))`, you type in :

```lisp
USER(1): (* 2 (cos 0) (+ 4 6))
```

Common LISP replies:

```
20.0
```

## Defining Functions

```lisp
USER(2): (defun double (x) (* x 2))
DOUBLE
```

In the above, we define a function named double, which returns two times the value of its input argument x. We can then test-drive the function as below:

```lisp
USER(3): (double 3)
6
USER(4): (double 7)
14
```

## Editing, Loading and Compiling LISP Programs

```lisp
;;;
;;; source1.lisp: Source code for LISP tutorial 1
;;; Philip W. L. Fong
;;; SFU CMPT 310 (2001-1)
;;;

;;
;; Defining Functions
;;

(defun my-double (x)
  "Compute two tmes X."
  (* 2 x))

;;
;; Editing, Loading and Compiling LISP Programs
;;

(defun my-triple (x)
  "Compute three times X." ; Inline comments can
  (* 3 x))                 ; be placed here.

;;
;; Negate the sign of a number
;;

(defun my-negate (x)
  (- x))
```

**Run:**

```lisp
CL-USER> (load "source1.lisp")
T
CL-USER> (my-double 3)
6 (3 bits, #x6, #o6, #b110)
CL-USER> (my-triple 4)
12 (4 bits, #xC, #o14, #b1100)
CL-USER> (my-negate 4)
-5 (3 bits)
```

## Control Stuctures: Recursions and Conditionals

```lisp
;;
;; Control Structures: Recursions and Conditionals
;;
(defun my-factorial (N)
  "Compute the factorial of N"
  (if (= n 1)
      1
      (* n (my-factorial (- n 1)))))
```

The N'th triangular number is defined to be <img src="https://render.githubusercontent.com/render/math?math=\sum_{i}^{n}a_i"/>. Alternatively, we could give a recursive definition of triangular number as follows:

```lisp
;;
;; Exercise: 1 + 2 + 3 + ... + N
;;
(defun my-triangular (N)
  "Compute the N'th triangular number."
  (if (= N 1)
      1
      (+ N (my-triangular (- N 1)))))
```

Write down a recursive definition of <img src="https://render.githubusercontent.com/render/math?math=B^E"/> (assuming that both _B_ and _E_ are non-negative integers). Then implement a linearly recursive function `(power B E)` that computes <img src="https://render.githubusercontent.com/render/math?math=B^E"/>. Enter your function definition into a text file. Then load it into LISP. Trace the execution of `(power 2 6)`.

```lisp
(defun my-power (B E)
  (if (zerop E)
      1
      (* B (my-power B (- E 1)))))
```

## Multiple Recursions

Recall the definition of Fibonacci numbers:

```
	Fib(n) = 1 		                  for n = 0 or n = 1
	Fib(n) = Fib(n-1) + Fib(n-2) 		for n > 1
```

```lisp
(defun my-fibonacci (N)
  "Compute the N'th Fibonacci number."
  (if (or (zerop N) (= N 1))
      1
      (+ (my-fibonacci (1- N)) (my-fibonacci (- N 2)))))
```

Some other built-in shorthands and predicates are the following:

| Shorthand  | Meaning          |
| ---------- | ---------------- |
| (1+ x)     | (+ x 1)          |
| (1- x)     | (- x 1)          |
| (zerop x)  | (= x 0)          |
| (plusp x)  | (> x 0)          |
| (minusp x) | (< x 0)          |
| (evenp x)  | (= (rem x 2) 0)  |
| (oddp x)   | (/= (rem x 2) 0) |

**Exercise**: The Binomial Coefficient `B(n, r)` is the coefficient of the term <img src="https://render.githubusercontent.com/render/math?math=x^r"/> in the binormial expansion of <img src="https://render.githubusercontent.com/render/math?math=(1 %2B x)^n"/> . For example, `B(4, 2) = 6` because <img src="https://render.githubusercontent.com/render/math?math=(1 %2B x)^4 = 1 %2B 4x %2B 6x^2 %2B 4x^3 %2B x^4"/> . The Binomial Coefficient can be computed using the Pascal Triangle formula:

```
B(n, r) = 1                       if r = 0 or r = n
B(n, r) = B(n-1, r-1) + B(n-1, r) otherwise
```

Implement a doubly recursive function `(binomial N R)` that computes the binomial coefficient `B(N, R)`.

```lisp
(defun my-binormial (N R)
  (if (or (zerop R) (= R N))
      1
      (+ (my-binormial (1- N) (1- R)) (my-binormial (1- N) R))))
```

Some beginners might find nested function calls like the following very difficult to understand:

```lisp
(+ (fibonacci (- N 1)) (fibonacci (- N 2)))))
```

The fibonacci function can thus be rewritten as follows with `let`:

```lisp
(defun my-fibonacci-2 (N)
  (if (or (zerop N) (= N 1))
      1
      (let ((F1 (my-fibonacci-2 (1- N)))
            (F2 (my-fibonacci-2 (- N 2))))
        (+ F1 F2))))
```

## Lists

Numeric values are not the only type of data LISP supports. LISP is designed for symbolic computing. The fundamental LISP data structure for supporting symbolic manipulation are lists. In fact, LISP stands for "LISt Processing."

Lists are containers that supports sequential traversal. List is also a _recursive data structure_: its definition is recursive. As such, most of its traversal algorithms are recursive functions. In order to better understand a recursive abstract data type and prepare oneself to develop recursive operations on the data type, one should present the data type in terms of its constructors, selectors and recognizers.

Constructors are forms that create new instances of a data type (possibly out of some simpler components). A list is obtained by evaluating one of the following constructors:

1. `nil`: Evaluating nil creates an _empty_ list;
1. `(cons x L)`: Given a LISP object _x_ and a list _L_, evaluating `(cons x L)` creates a list containing _x_ followed by the elements in _L_.

```lisp
CL-USER> (cons 1 (cons 2 nil))
(1 2)
```

```lisp
CL-USER> (quote (2 3 4 7 8 13))
(2 3 4 7 8 13)
```

The quote symbol `'` is nothing but a syntactic shorthand for `(quote ...)`.

```lisp
CL-USER> '(2 3 4 7 8 13)
(2 3 4 7 8 13)
```

```lisp
CL-USER> (first '(2 4 8))
2
CL-USER> (rest '(2 4 8))
(4 8)
CL-USER> (first (rest '(2 4 8)))
4
CL-USER> (rest (rest '(2 4 8)))
(8)
CL-USER> (rest (rest (rest '(8))))
NIL
```

```lisp
CL-USER> (null nil)
T
CL-USER> (consp nil)
NIL
CL-USER> (consp '(1 2 3))
T
```

## Structural Recursion with Lists

As we have promised, understanding how the constructors, selectors and recognizers of lists work helps us to develop recursive functions that traverse a list. Let us begin with an example. The LISP built-in function list-length counts the number of elements in a list. For example,

```lisp
(defun my-list-length (L)
  "A recursive implementation of list-length."
  (if (null L)
      0
      (1+ (my-list-length (rest L)))))
```

**Exercise**: Implement a linearly recursive function (sum L) which computes the sum of all numbers in a list L. Compare your solution with the standard pattern of structural recursion.

```lisp
(defun my-list-sum (L)
  "A recursive implementation of list-sum"
  (if (null L)
      0
      (+ (first L) (my-list-sum (rest L)))))
```
